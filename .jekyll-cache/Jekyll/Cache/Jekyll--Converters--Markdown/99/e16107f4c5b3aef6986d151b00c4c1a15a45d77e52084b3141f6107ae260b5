I"<p>The C++ STL provides four components:</p>
<ol>
  <li>algorithms</li>
  <li>containers</li>
  <li>iterators</li>
  <li>functions</li>
</ol>

<h3 id="containers">Containers</h3>
<p>Containers store data with specific structure:</p>
<ul>
  <li>standard STL sequence containers : <strong>vector, string, dequeue, list</strong></li>
  <li>standard STL associative containers : <strong>set, multiset, map,  multimap</strong></li>
  <li>
    <p>standard non-STL containers : <strong>bitset, valarray, stack, queue, priority_queue</strong></p>
  </li>
  <li><strong>list</strong> should be used when there are frequent insertions and deletions from the middle of the sequence.</li>
  <li><strong>deque</strong> should be used when most insertions and deletions take place at the beginning or at the end of the sequence.</li>
</ul>

<p>Contiguous-memory containers</p>

<ul>
  <li>Container in which more than one element is stored in the allocated chunk of memory. If an element in the chunk is inserted or deleted, the rest of the elements need to be shifted up or down in the memory.</li>
  <li>Ex: <strong>vector, string, dequeue</strong></li>
</ul>

<p>Node-based containers</p>

<ul>
  <li>Containers that can allocate one element per chunk.</li>
  <li>Ex: <strong>set, list</strong></li>
</ul>

<hr />

<h4 id="item-encapsulation">Item: Encapsulation</h4>

<p>While writing containers try to encapsulate things:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">vw</span><span class="p">;</span>
<span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span>                   <span class="c1">// find a Widget with the</span>
  <span class="n">find</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidget</span><span class="p">);</span>      <span class="c1">// same value as bestWidget</span></code></pre></figure>

<p>Instead of the above code, this code makes more sense:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">WidgetContainer</span><span class="p">;</span>
<span class="n">Widget</span> <span class="n">bestWidget</span><span class="p">;</span>

<span class="n">WidgetContainer</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span>                   <span class="c1">// find a Widget with the</span>
  <span class="n">find</span><span class="p">(</span><span class="n">vw</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vw</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bestWidget</span><span class="p">);</span>      <span class="c1">// same value as bestWidget</span></code></pre></figure>

<p>The above code is more robust to the changes made to the container late on.</p>

<hr />

<h4 id="item-empty-vs-size">Item: empty() vs size()</h4>

<p>It seems like checking for empty and size against zero should be the same.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="k">if</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></code></pre></figure>

<p>One should always prefer <code class="language-plaintext highlighter-rouge">empty()</code> operation because:</p>
<ul>
  <li>Its generally implemented inline, which checks if size is 0.</li>
  <li>It takes constant time. In case of <code class="language-plaintext highlighter-rouge">list</code>, the <code class="language-plaintext highlighter-rouge">size()</code> takes linear time.</li>
</ul>

<hr />

<h4 id="item-range-operators">Item: range operators</h4>

<p>Use <code class="language-plaintext highlighter-rouge">assign()</code> operator to assign values to container.</p>

<p>To assign <code class="language-plaintext highlighter-rouge">v2</code>â€™s half content to <code class="language-plaintext highlighter-rouge">v1</code>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">v1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre></figure>

<p>The above code does not require any loop. It takes the range from iterators as input.</p>
:ET